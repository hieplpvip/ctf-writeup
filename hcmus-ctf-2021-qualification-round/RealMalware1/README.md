## RealMalware1 (100 points)

#### Solved by hieplpvip

```
A new ransomware is spreading wide, and xikhud is one of those victims. All of is data got encrypted. He sent a folder of encrypted data, and of course a sample of the malware to HCMUSML (HCMUS' Malware Laboratory) in the hope of getting back his data. Our researchers found that the malware sample was heavily obfuscated, but they had successfully decompiled, and translated it back to the C source code form. Unfortunately, they don't know how to decrypt the data. Can you help them ?

https://drive.google.com/drive/folders/1sCYquM-UZyLdr4qtB9mkxmAjkXSeKypB?usp=sharing

author: xikhud
```

From the source code, we know that:

- Files with extensions `exe`, `png`, or `pdf` are encrypted by `encrypt1`
- Other files are encrypted by `encrypt2`
- `encrypt2` xor the files with the key `0xDEADC0DE`. To decrypt, just xor again.
- `encrypt1` is XTEA, but the key is generated randomly at runtime. We can find XTEA decryption implementation online.

We decrypt `flag.txt.enc` and get the hint:

```
Flag is not here.
But, keep going.

Since you're here, I will give you a gift: the first 3 least significant bits of key is 110.
What you gonna do ?

Good luck.
```

`encrypt1` uses 32-bit key, and we already know 3, so we just need to brute force 29 bits. 2^29 is about 5e8, so it should run pretty fast. To save time, we only decrypt the first 4 bits of each file and check against known file signature:

- PNG: 0x89504E47
- EXE: 0x4d5a9000
- PDF: 0x25504446

I was able to find the key for `HelloWorld.exe.enc`, `RSA.pdf.enc`, and `coronaviruspdfhac4.pdf.enc`. They were all encrypted with key 0x806E17FE (which makes sense because they were probably encrypted at the same time). However, that key didn't work for `flag.png.enc`, and I couldn't find any other hints in the decrypted files, so I decided to brute force all 32 bits.

To my surprise, the key for `flag.png.enc` was 0. It turned out that there was some mistakes from the author.

![](flag.png)

**Flag:** `HCMUS-CTF{xxdd112233445566}`

### Decryption code

```cpp
#include <bits/stdc++.h>

#define MIN(a, b) ((a) < (b) ? (a) : (b))
#define err(fmt, ...) fprintf(stderr, fmt, __VA_ARGS__)

#define FREAD_BLOCK_SIZE (2048)
#define FWRITE_BLOCK_SIZE (2048)
#define ENC_BLOCK_SIZE (2)
#define ENC_NUM_ROUND (64)
#define KEY_SIZE (4)

using namespace std;

static unsigned char g_key1[KEY_SIZE];
static unsigned int g_key2 = (0xDE << 24) | (0xAD << 16) | (0xC0 << 8) | (0xDE);

std::ifstream::pos_type filesize(const char* filename) {
  std::ifstream in(filename, std::ifstream::ate | std::ifstream::binary);
  return in.tellg();
}

// xtea
void decrypt1(unsigned int nRound, unsigned char v[ENC_BLOCK_SIZE], unsigned char key[KEY_SIZE]) {
  unsigned char v0 = v[0], v1 = v[1];
  unsigned int delta = 0x9E3779B9, sum = delta * nRound;
  for (unsigned int i = 0; i < nRound; ++i) {
    v1 -= (((v0 << 4) ^ (v0 >> 5)) + v0) ^ (sum + key[(sum >> 11) % KEY_SIZE]);
    sum -= delta;
    v0 -= (((v1 << 4) ^ (v1 >> 5)) + v1) ^ (sum + key[sum % KEY_SIZE]);
  }
  v[0] = v0;
  v[1] = v1;
}

void decrypt2(unsigned char* data, unsigned int dataLength, unsigned char* key, unsigned int keyLength) {
  for (unsigned int i = 0; i < dataLength; ++i) {
    data[i] = data[i] ^ key[i % keyLength];
  }
}

void decrypt_file1(const char* filename, const char* dec) {
  unsigned int fileSize = filesize(filename);
  FILE* f = fopen(filename, "rb");
  unsigned char* lpBuffer = (unsigned char*)malloc(fileSize);
  unsigned int nRead = 0;
  while (nRead < fileSize) {
    int n = fread((void*)(lpBuffer + nRead), sizeof(unsigned char), MIN(FREAD_BLOCK_SIZE, fileSize - nRead), f);
    nRead += n;
  }
  fclose(f);

  unsigned int nBlock = fileSize / ENC_BLOCK_SIZE;
  for (unsigned int i = 0; i < nBlock; ++i) {
    decrypt1(ENC_NUM_ROUND, &lpBuffer[2 * i], g_key1);
  }

  FILE* newFile = fopen(dec, "wb");
  unsigned int nWrite = 0;
  while (nWrite < fileSize) {
    int n = fwrite((const void*)(lpBuffer + nWrite), sizeof(unsigned char), MIN(FWRITE_BLOCK_SIZE, fileSize - nWrite), newFile);
    nWrite += n;
  }
  fclose(newFile);
  free(lpBuffer);
}

void decrypt_file2(const char* filename, const char* dec) {
  unsigned int fileSize = filesize(filename);
  FILE* f = fopen(filename, "rb");
  unsigned char* lpBuffer = (unsigned char*)malloc(fileSize);
  unsigned int nRead = 0;
  while (nRead < fileSize) {
    int n = fread((void*)(lpBuffer + nRead), sizeof(unsigned char), MIN(FREAD_BLOCK_SIZE, fileSize - nRead), f);
    nRead += n;
  }
  fclose(f);

  decrypt2(lpBuffer, fileSize, (unsigned char*)&g_key2, KEY_SIZE);

  FILE* newFile = fopen(dec, "wb");
  unsigned int nWrite = 0;
  while (nWrite < fileSize) {
    int n = fwrite((const void*)(lpBuffer + nWrite), sizeof(unsigned char), MIN(FWRITE_BLOCK_SIZE, fileSize - nWrite), newFile);
    nWrite += n;
  }
  fclose(newFile);
  free(lpBuffer);
}

void brute_force(unsigned char enc[4]) {
#ifdef BRUTE_ALL
  unsigned int mx = UINT_MAX;
#else
  unsigned int mx = 1 << 29;
#endif

  unsigned char dec[4];
  for (unsigned int x = 0; x < mx; ++x) {
#ifdef BRUTE_ALL
    *(unsigned int*)g_key1 = x;
#else
    *(unsigned int*)g_key1 = (x << 3) | 6;
#endif

    memcpy(dec, enc, 4);
    decrypt1(ENC_NUM_ROUND, &dec[0], g_key1);
    decrypt1(ENC_NUM_ROUND, &dec[2], g_key1);

    // PNG
    if (dec[0] == 0x89 && dec[1] == 0x50 && dec[2] == 0x4E && dec[3] == 0x47) {
      cout << *(unsigned int*)g_key1 << "PNG\n";
    }

    // EXE
    if (dec[0] == 0x4d && dec[1] == 0x5a && dec[2] == 0x90 && dec[3] == 0x00) {
      cout << *(unsigned int*)g_key1 << "EXE\n";
    }

    // PDF
    if (dec[0] == 0x25 && dec[1] == 0x50 && dec[2] == 0x44 && dec[3] == 0x46) {
      cout << *(unsigned int*)g_key1 << "PDF\n";
    }
  }
}

int main() {
  *(unsigned int*)g_key1 = 0;
  decrypt_file1("flag.png.enc", "flag.png");

  *(unsigned int*)g_key1 = 2154698750;
  decrypt_file1("HelloWorld.exe.enc", "HelloWorld.exe");

  *(unsigned int*)g_key1 = 2154698750;
  decrypt_file1("RSA.pdf.enc", "RSA.pdf");
  decrypt_file1("coronaviruspdfhac4.pdf.enc", "coronaviruspdfhac4.pdf");

  decrypt_file2("Bai tap.docx.enc", "Bai tap.docx");
  decrypt_file2("flag.txt.enc", "flag.txt");
  decrypt_file2("maybe hint.jpg.enc", "maybe hint.jpg");
  decrypt_file2("Money.xlsx.enc", "Money.xlsx");

  //unsigned char flag_enc[4] = {0x27, 0x58, 0xfb, 0xc6};  // flag.png.enc
  //brute_force(flag_enc);

  //unsigned char helloworld_enc[4] = {0xf3, 0x33, 0xd5, 0x04};  // HelloWorld.exe.enc
  //brute_force(helloworld_enc);

  //unsigned char pdf_enc[4] = {0xc6, 0x91, 0xec, 0x6b};  // RSA.pdf.enc and coronaviruspdfhac4.pdf.enc
  //brute_force(pdf_enc);

  return 0;
}
```

### References

- [https://en.wikipedia.org/wiki/XTEA](https://en.wikipedia.org/wiki/XTEA)
